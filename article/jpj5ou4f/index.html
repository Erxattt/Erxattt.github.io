<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.18" /><meta name="theme" content="VuePress Theme Plume " /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><title>数据结构 | My Vuepress Site</title><meta name="description" content=""><link rel="preload" href="/assets/style-ky3X728O.css" as="style"><link rel="stylesheet" href="/assets/style-ky3X728O.css"><link rel="modulepreload" href="/assets/app-H92NnqWz.js"><link rel="modulepreload" href="/assets/index.html-Crh1-Gog.js"><link rel="prefetch" href="/assets/Java基础.html-5luXHv2A.js" as="script"><link rel="prefetch" href="/assets/index.html-Bd-AdLLE.js" as="script"><link rel="prefetch" href="/assets/Redis.html-C3qn4t3i.js" as="script"><link rel="prefetch" href="/assets/Springboot整合系列.html-Pv_rGAyd.js" as="script"><link rel="prefetch" href="/assets/elasticsearch的安装与java客户端使用.html-D03Qjf0h.js" as="script"><link rel="prefetch" href="/assets/index.html-D3ctxwwb.js" as="script"><link rel="prefetch" href="/assets/mysql内置函数.html-B5njg4FL.js" as="script"><link rel="prefetch" href="/assets/rabbitmq.html-DRpkBTpW.js" as="script"><link rel="prefetch" href="/assets/index.html-C7vi6l1P.js" as="script"><link rel="prefetch" href="/assets/学习mybatis3.html-CGOuHWwl.js" as="script"><link rel="prefetch" href="/assets/index.html-Cbp9ys1I.js" as="script"><link rel="prefetch" href="/assets/index.html-CkOm8FqW.js" as="script"><link rel="prefetch" href="/assets/index.html-DDvckX88.js" as="script"><link rel="prefetch" href="/assets/index.html-3GGYU2_b.js" as="script"><link rel="prefetch" href="/assets/index.html-CPBkL1MW.js" as="script"><link rel="prefetch" href="/assets/index.html-Bljx-l0K.js" as="script"><link rel="prefetch" href="/assets/index.html-CA1Gkw55.js" as="script"><link rel="prefetch" href="/assets/index.html-Cws0mlJk.js" as="script"><link rel="prefetch" href="/assets/index.html-ghf7iUPk.js" as="script"><link rel="prefetch" href="/assets/index.html-T0MXA6PY.js" as="script"><link rel="prefetch" href="/assets/index.html-Dml0IyEO.js" as="script"><link rel="prefetch" href="/assets/index.html-BTRgploU.js" as="script"><link rel="prefetch" href="/assets/index.html-Ckk_jSi4.js" as="script"><link rel="prefetch" href="/assets/404.html-CyhAVWHn.js" as="script"><link rel="prefetch" href="/assets/index.html-B-06hZdx.js" as="script"><link rel="prefetch" href="/assets/index.html-Db2lNgo1.js" as="script"><link rel="prefetch" href="/assets/index.html-BWwEJZ4B.js" as="script"><link rel="prefetch" href="/assets/index.html-fIpZ1LZl.js" as="script"><link rel="prefetch" href="/assets/index.html-DRJFfUuf.js" as="script"><link rel="prefetch" href="/assets/index.html-Bs7590PU.js" as="script"><link rel="prefetch" href="/assets/index.html-CAIdy0WR.js" as="script"><link rel="prefetch" href="/assets/index.html-Cfc3D0hm.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-GXRgw7eJ.js" as="script"><link rel="prefetch" href="/assets/searchBox-default-BvMutqnE.js" as="script"><link rel="prefetch" href="/assets/searchBox-en-Dur5JG6Y.js" as="script"><link rel="prefetch" href="/assets/SearchBox-DIiJtW0-.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-7MC2TMWH-BS4bsi5I.js" as="script"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-68cd6b44><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-d5a8d0bc></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-d5a8d0bc> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-68cd6b44 data-v-d34f28d6><div class="vp-navbar" vp-navbar data-v-d34f28d6 data-v-70d97d16><div class="wrapper" data-v-70d97d16><div class="container" data-v-70d97d16><div class="title" data-v-70d97d16><div class="vp-navbar-title" data-v-70d97d16 data-v-2c8d4622><a class="vp-link no-icon link title" href="/" data-v-2c8d4622 data-v-442a52aa><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" src="https://theme-plume.vuejs.press/plume.png" alt data-v-7fbfbc9b><!--]--><!--[--><img class="vp-image light logo" src="https://theme-plume.vuejs.press/plume.png" alt data-v-7fbfbc9b><!--]--><!--]--><!--]--><span data-v-2c8d4622>My Vuepress Site</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-70d97d16><div class="content-body" data-v-70d97d16><!--[--><!--]--><div class="vp-navbar-search search" data-v-70d97d16><div class="search-wrapper" data-v-97535d1e><!----><div id="local-search" data-v-97535d1e><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-97535d1e><span class="mini-search-button-container"><svg class="mini-search-search-icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-70d97d16 data-v-d43c1732><span id="main-nav-aria-label" class="visually-hidden" data-v-d43c1732>Main Navigation</span><!--[--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/" tabindex="0" data-v-d43c1732 data-v-9970a379 data-v-442a52aa><!--[--><!----><span data-v-9970a379>首页</span><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/" tabindex="0" data-v-d43c1732 data-v-9970a379 data-v-442a52aa><!--[--><!----><span data-v-9970a379>博客</span><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/tags/" tabindex="0" data-v-d43c1732 data-v-9970a379 data-v-442a52aa><!--[--><!----><span data-v-9970a379>标签</span><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/archives/" tabindex="0" data-v-d43c1732 data-v-9970a379 data-v-442a52aa><!--[--><!----><span data-v-9970a379>归档</span><!--]--><!----></a><!--]--><!--[--><div class="vp-flyout vp-navbar-menu-group" data-v-d43c1732 data-v-feafea4e><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-feafea4e><span class="text" data-v-feafea4e><!----><!----><span data-v-feafea4e>笔记</span><span class="vpi-chevron-down text-icon" data-v-feafea4e></span></span></button><div class="menu" data-v-feafea4e><div class="vp-menu" data-v-feafea4e data-v-709dc2b1><div class="items" data-v-709dc2b1><!--[--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-aaf95230><a class="vp-link no-icon link" href="/demo/" data-v-aaf95230 data-v-442a52aa><!--[--><!----> 示例<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><div class="vp-flyout vp-navbar-translations translations" data-v-70d97d16 data-v-f5263507 data-v-feafea4e><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="选择语言" data-v-feafea4e><span class="text" data-v-feafea4e><!----><span class="vpi-languages option-icon" data-v-feafea4e></span><!----><span class="vpi-chevron-down text-icon" data-v-feafea4e></span></span></button><div class="menu" data-v-feafea4e><div class="vp-menu" data-v-feafea4e data-v-709dc2b1><!----><!--[--><!--[--><div class="items" data-v-f5263507><p class="title" data-v-f5263507>简体中文</p><!--[--><div class="vp-menu-link" data-v-f5263507 data-v-aaf95230><a class="vp-link no-icon link" href="/blog/" data-v-aaf95230 data-v-442a52aa><!--[--><!----> English<!--]--><!----></a></div><!--]--></div><!--]--><!--]--></div></div></div><div class="vp-navbar-appearance appearance" data-v-70d97d16 data-v-a295abf6><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a295abf6 data-v-537740e0 data-v-d84fedac><span class="check" data-v-d84fedac><span class="icon" data-v-d84fedac><!--[--><span class="vpi-sun sun" data-v-537740e0></span><span class="vpi-moon moon" data-v-537740e0></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-70d97d16 data-v-ad52545c data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-70d97d16 data-v-652282fd data-v-feafea4e><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-feafea4e><span class="vpi-more-horizontal icon" data-v-feafea4e></span></button><div class="menu" data-v-feafea4e><div class="vp-menu" data-v-feafea4e data-v-709dc2b1><!----><!--[--><!--[--><div class="group translations" data-v-652282fd><p class="trans-title" data-v-652282fd>简体中文</p><!--[--><div class="vp-menu-link" data-v-652282fd data-v-aaf95230><a class="vp-link no-icon link" href="/blog/" data-v-aaf95230 data-v-442a52aa><!--[--><!----> English<!--]--><!----></a></div><!--]--></div><div class="group" data-v-652282fd><div class="item appearance" data-v-652282fd><p class="label" data-v-652282fd>外观</p><div class="appearance-action" data-v-652282fd><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-652282fd data-v-537740e0 data-v-d84fedac><span class="check" data-v-d84fedac><span class="icon" data-v-d84fedac><!--[--><span class="vpi-sun sun" data-v-537740e0></span><span class="vpi-moon moon" data-v-537740e0></span><!--]--></span></span></button></div></div></div><div class="group" data-v-652282fd><div class="item social-links" data-v-652282fd><div class="vp-social-links social-links-list" data-v-652282fd data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="/" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-70d97d16 data-v-2b50024d><span class="container" data-v-2b50024d><span class="top" data-v-2b50024d></span><span class="middle" data-v-2b50024d></span><span class="bottom" data-v-2b50024d></span></span></button></div></div></div></div><div class="divider" data-v-70d97d16><div class="divider-line" data-v-70d97d16></div></div></div><!----></header><div class="vp-local-nav fixed reached-top is-blog" data-v-68cd6b44 data-v-1dc3518c><button class="hidden menu" disabled aria-expanded="false" aria-controls="SidebarNav" data-v-1dc3518c><span class="vpi-align-left menu-icon" data-v-1dc3518c></span><span class="menu-text" data-v-1dc3518c>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-1dc3518c data-v-423a73ec><button data-v-423a73ec>返回顶部</button><!----></div></div><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-68cd6b44 data-v-eb709286><div class="is-blog vp-doc-container" data-v-1317b5aa><!--[--><!--]--><div class="container" data-v-1317b5aa><!----><div class="content" data-v-1317b5aa><div class="content-container" data-v-1317b5aa><!--[--><!--]--><main class="main" data-v-1317b5aa><!----><!--[--><h1 class="vp-doc-title page-title" data-v-8593162d>数据结构 <!----></h1><div class="vp-doc-meta" data-v-8593162d><p class="reading-time" data-v-8593162d><span class="vpi-books icon" data-v-8593162d></span><span data-v-8593162d>4517字</span><span data-v-8593162d>约15分钟</span></p><!----><p class="create-time" data-v-8593162d><span class="vpi-clock icon" data-v-8593162d></span><span data-v-8593162d>2024-11-21</span></p></div><!--]--><div class="vp-doc plume-content _article_jpj5ou4f_ external-link-icon-enabled" vp-content data-v-1317b5aa><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><h3 id="直接插入排序" tabindex="-1"><a class="header-anchor" href="#直接插入排序"><span>直接插入排序</span></a></h3><p>直接插入排序是一种简单直观的排序算法。其基本思想是模拟打扑克牌时的整理过程：将牌一张张抽出，依次插入到合适的位置，使得手中的牌始终保持有序。对于每一个新元素，我们将其与前面的已排序元素进行比较，找到适当的位置插入，从而保持部分有序，直到处理完所有元素，最终实现整个数组的有序排列。</p><h4 id="直接插入排序的特点" tabindex="-1"><a class="header-anchor" href="#直接插入排序的特点"><span>直接插入排序的特点</span></a></h4><ol><li><strong>时间复杂度</strong>：平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最好情况为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>（数组已基本有序），最坏情况为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（逆序数组）。</li><li><strong>空间复杂度</strong>：为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，因为直接插入排序在原数组上操作，不需要额外的存储空间。</li><li><strong>稳定性</strong>：直接插入排序是稳定的，相同元素的相对顺序不会改变。</li></ol><hr><h4 id="直接插入排序的过程" tabindex="-1"><a class="header-anchor" href="#直接插入排序的过程"><span>直接插入排序的过程</span></a></h4><p>直接插入排序的核心思想是将数组分为已排序和未排序两部分，逐步将未排序部分的元素插入到已排序部分的合适位置：</p><ol><li>从数组的第二个元素开始，依次将每个元素插入到其前方已排序部分的正确位置。</li><li>比较时，从当前元素逐个向前，与已排序部分的元素比较并后移，直到找到合适的位置插入。</li></ol><hr><h4 id="直接插入排序的步骤示例" tabindex="-1"><a class="header-anchor" href="#直接插入排序的步骤示例"><span>直接插入排序的步骤示例</span></a></h4><p>假设我们有数组 <code>[5, 2, 9, 1, 5, 6]</code>，我们使用直接插入排序对其进行升序排序。</p><h5 id="初始数组" tabindex="-1"><a class="header-anchor" href="#初始数组"><span>初始数组</span></a></h5><p>数组初始状态为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[5, 2, 9, 1, 5, 6]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h5 id="第一步-插入元素-2" tabindex="-1"><a class="header-anchor" href="#第一步-插入元素-2"><span>第一步：插入元素 2</span></a></h5><p>将 <code>2</code> 插入到已排序部分 <code>[5]</code> 中的合适位置：</p><ul><li><p><code>2</code> 小于 <code>5</code>，所以将 <code>5</code> 后移，<code>2</code> 插入到第一个位置。</p></li><li><p>结果为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[2, 5, 9, 1, 5, 6]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><hr><h5 id="第二步-插入元素-9" tabindex="-1"><a class="header-anchor" href="#第二步-插入元素-9"><span>第二步：插入元素 9</span></a></h5><p>将 <code>9</code> 插入到已排序部分 <code>[2, 5]</code> 的合适位置：</p><ul><li><p><code>9</code> 大于 <code>5</code>，不需要移动，直接插入到当前位置。</p></li><li><p>结果为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[2, 5, 9, 1, 5, 6]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><hr><h5 id="第三步-插入元素-1" tabindex="-1"><a class="header-anchor" href="#第三步-插入元素-1"><span>第三步：插入元素 1</span></a></h5><p>将 <code>1</code> 插入到已排序部分 <code>[2, 5, 9]</code> 中的合适位置：</p><ul><li><p><code>1</code> 小于 <code>9</code>，将 <code>9</code> 后移。</p></li><li><p><code>1</code> 小于 <code>5</code>，将 <code>5</code> 后移。</p></li><li><p><code>1</code> 小于 <code>2</code>，将 <code>2</code> 后移，将 <code>1</code> 插入第一个位置。</p></li><li><p>结果为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 5, 9, 5, 6]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><hr><h5 id="第四步-插入元素-5" tabindex="-1"><a class="header-anchor" href="#第四步-插入元素-5"><span>第四步：插入元素 5</span></a></h5><p>将 <code>5</code> 插入到已排序部分 <code>[1, 2, 5, 9]</code> 的合适位置：</p><ul><li><p><code>5</code> 小于 <code>9</code>，将 <code>9</code> 后移，<code>5</code> 插入到第二个 <code>5</code> 的位置。</p></li><li><p>结果为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 5, 5, 9, 6]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><hr><h5 id="第五步-插入元素-6" tabindex="-1"><a class="header-anchor" href="#第五步-插入元素-6"><span>第五步：插入元素 6</span></a></h5><p>将 <code>6</code> 插入到已排序部分 <code>[1, 2, 5, 5, 9]</code> 的合适位置：</p><ul><li><p><code>6</code> 小于 <code>9</code>，将 <code>9</code> 后移，<code>6</code> 插入 <code>9</code> 的位置。</p></li><li><p>结果为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 5, 5, 6, 9]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序"><span>希尔排序</span></a></h3><p>希尔排序（<em><strong>Shell Sort</strong></em>）是一种<strong>基于插入排序</strong>的<strong>改进</strong>排序算法。它通过<strong>分组</strong>和<strong>逐步减少间隔</strong>的方式，使得数组中的元素逐步接近有序状态，然后在最后进行一次普通插入排序完成整个排序。希尔排序得名于发明者唐纳德·希尔（Donald Shell），它适合中小规模数据的排序，具有较高的效率。</p><h4 id="希尔排序的特点" tabindex="-1"><a class="header-anchor" href="#希尔排序的特点"><span>希尔排序的特点</span></a></h4><ul><li><strong>时间复杂度</strong>：根据不同的间隔序列，时间复杂度介于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>之间，通常优于简单插入排序。</li><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，是原地排序算法。</li><li><strong>稳定性</strong>：希尔排序是不稳定的排序算法，因为在分组排序过程中，可能会改变相等元素的相对顺序。</li></ul><h4 id="希尔排序的过程" tabindex="-1"><a class="header-anchor" href="#希尔排序的过程"><span>希尔排序的过程</span></a></h4><ol><li><strong>确定初始间隔（增量）</strong>：选一个较大的间隔将数组分组，例如将间隔定为数组长度的一半。</li><li><strong>分组排序</strong>：按间隔将数组分为多个子序列，每个子序列进行插入排序。</li><li><strong>缩小间隔</strong>：逐步减小间隔，重复分组排序，直到间隔为1时执行一次完整的插入排序。</li><li><strong>结束</strong>：当间隔为1且完成排序后，整个数组已达到有序状态。</li></ol><h4 id="希尔排序的步骤" tabindex="-1"><a class="header-anchor" href="#希尔排序的步骤"><span>希尔排序的步骤</span></a></h4><p>假设我们有一个数组 <code>[49, 38, 65, 97, 76, 13, 27, _49]</code>，希尔排序过程如下：</p><ol><li><strong>第一趟排序</strong>（间隔 = 4）： <ul><li>选择初始间隔为 <code>4</code>，将数组分成四组分别进行插入排序： <ul><li><code>[49, 76]</code>, <code>[38, 13]</code>, <code>[65, 27]</code>, <code>[97, _49]</code></li></ul></li><li>排序后： <ul><li><code>[49, 13, 27, _49, 76, 38, 65, 97]</code></li></ul></li></ul></li><li><strong>第二趟排序</strong>（间隔 = 2）： <ul><li>将间隔缩小为 <code>2</code>，分成两组进行插入排序： <ul><li><code>[49, 27, 76, 65]</code>, <code>13, _49, 38, 97]</code></li></ul></li><li>排序后： <ul><li><code>[27, 13, 49, 38, 65, _49, 76, 97]</code></li></ul></li></ul></li><li><strong>第三趟排序</strong>（间隔 = 1）： <ul><li>间隔缩小为 <code>1</code>，相当于对整个数组进行一次插入排序： <ul><li><code>[13, 27, 38, 49, _49, 65, 76, 97]</code></li></ul></li></ul></li></ol><p>此时，数组已完全有序，排序完成。</p><h3 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序"><span>快速排序</span></a></h3><p>快速排序的核心思想是通过<strong>选择一个基准元素（pivot）</strong>，将数组分为两部分：一部分小于基准元素，另一部分大于基准元素。具体步骤如下：</p><ol><li><strong>选择基准元素</strong>：通常选择数组中的某个元素作为基准（常用的是第一个元素、最后一个元素或随机元素）。</li><li><strong>分割</strong>：通过比较，调整数组元素的位置，使得基准元素左边的元素都小于基准，右边的元素都大于基准。</li><li><strong>递归排序</strong>：对基准元素左右两边的子数组分别进行递归排序。</li><li><strong>合并</strong>：由于分割后子数组在原数组上，合并过程自然完成。</li></ol><hr><h4 id="快速排序的步骤示例" tabindex="-1"><a class="header-anchor" href="#快速排序的步骤示例"><span>快速排序的步骤示例</span></a></h4><p>假设我们有数组 <code>[8, 4, 7, 6, 3, 5, 2, 1]</code>，要使用快速排序对其进行升序排序。</p><h5 id="初始数组-1" tabindex="-1"><a class="header-anchor" href="#初始数组-1"><span>初始数组</span></a></h5><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[3, 7, 8, 5, 2, 1, 9, 5, 4]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><p>第一步：选择基准元素并分割</p><p>选择数组的最后一个元素 <code>4</code> 作为基准，将小于 <code>4</code> 的元素移到左边，大于 <code>4</code> 的移到右边。</p><ol><li><p><strong>当前基准</strong>：<code>4</code></p></li><li><p><strong>开始分割</strong>：</p><ul><li><p>从左到右遍历数组，把小于 <code>4</code> 的元素换到左侧。</p></li><li><p><strong>第一轮比较</strong>：</p><ul><li><p><code>3</code> 小于 <code>4</code>，不用移动。</p></li><li><p><code>7</code> 大于 <code>4</code>，跳过。</p></li><li><p><code>8</code> 大于 <code>4</code>，跳过。</p></li><li><p><code>5</code> 大于 <code>4</code>，跳过。</p></li><li><p><code>2</code>小于 <code>4</code>，交换 <code>2</code>和 <code>7</code>：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[3, 2, 8, 5, 7, 1, 9, 5, 4]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><code>1</code>小于 <code>4</code>，交换 <code>1</code>和 <code>8</code>：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[3, 2, 1, 5, 7, 8, 9, 5, 4]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><code>9</code> 大于 <code>4</code>，跳过。</p></li><li><p><code>5</code> 大于 <code>4</code>，跳过。</p></li></ul></li></ul></li><li><p><strong>交换基准</strong>：将基准 <code>4</code> 放到中间位置，与 <code>5</code> 交换：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[3, 2, 1, 4, 7, 8, 9, 5, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>分割结果</strong>：基准 <code>4</code> 将数组分成两部分：左侧 <code>[3, 2, 1]</code> 和右侧 <code>[7, 8, 9, 5, 5]</code>。</p></li></ol><hr><p>第二步：递归排序左侧子数组 <code>[3, 2, 1]</code></p><p>对左侧子数组 <code>[3, 2, 1]</code> 选择 <code>1</code> 为基准，进行排序。</p><ol><li><p><strong>当前基准</strong>：<code>1</code></p></li><li><p><strong>分割</strong>：</p><ul><li><p>遍历 <code>[3, 2]</code>，发现都大于 <code>1</code>，所以 <code>1</code> 应该放到最左边。</p></li><li><p>交换 <code>1</code>和 <code>3</code>：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 3, 4, 7, 8, 9, 5, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p><strong>左侧子数组已排序</strong>：得到 <code>[1, 2, 3]</code>。</p></li></ol><hr><p>第三步：递归排序右侧子数组 <code>[7, 8, 9, 5, 5]</code></p><p>对右侧子数组 <code>[7, 8, 9, 5, 5]</code> 选择最后一个元素 <code>5</code> 为基准。</p><ol><li><p><strong>当前基准</strong>：<code>5</code></p></li><li><p><strong>分割</strong>：</p><ul><li>遍历 <code>[7, 8, 9, 5]</code>，将小于 <code>5</code> 的元素移到左边。</li><li>第一轮比较： <ul><li><code>7</code> 大于 <code>5</code>，跳过。</li><li><code>8</code> 大于 <code>5</code>，跳过。</li><li><code>9</code> 大于 <code>5</code>，跳过。</li><li><code>5</code> 等于 <code>5</code>，保持不变。</li></ul></li></ul></li><li><p><strong>交换基准</strong>：将 <code>5</code> 放到中间位置，与 <code>7</code> 交换：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 3, 4, 5, 8, 9, 7, 5]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>分割结果</strong>：基准 <code>5</code> 分割出 <code>[5]</code> 和 <code>[8, 9, 7]</code>。</p></li></ol><hr><p>第四步：继续递归排序右侧子数组 <code>[8, 9, 7]</code></p><p>对 <code>[8, 9, 7]</code> 选择 <code>7</code> 为基准进行排序。</p><ol><li><p><strong>当前基准</strong>：<code>7</code></p></li><li><p><strong>分割</strong>：</p><ul><li><p>遍历 <code>[8, 9]</code>，发现都大于 <code>7</code>，所以 <code>7</code> 应放在最左边。</p></li><li><p>交换 <code>7</code>和 <code>8</code>：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 3, 4, 5, 5, 7, 8, 9]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p><strong>右侧子数组已排序</strong>：得到 <code>[7, 8, 9]</code>。</p></li></ol><hr><h5 id="最终结果" tabindex="-1"><a class="header-anchor" href="#最终结果"><span>最终结果</span></a></h5><p>快速排序完成后，整个数组为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 2, 3, 4, 5, 5, 7, 8, 9]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h3><p>冒泡排序（<em>Bubble Sort</em>）是一种简单的排序算法，它通过多次比较和交换相邻的元素，将较大的元素逐步“冒泡”到数组的末尾。冒泡排序适合对小规模数据进行排序，但在大规模数据上效率较低。</p><h4 id="冒泡排序的特点" tabindex="-1"><a class="header-anchor" href="#冒泡排序的特点"><span>冒泡排序的特点</span></a></h4><ul><li><strong>时间复杂度</strong>：最坏和平均情况下的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为需要对每对元素进行比较。</li><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，它是原地排序算法，不需要额外的存储空间。</li><li><strong>稳定性</strong>：冒泡排序是稳定的排序算法，两个相等的元素在排序后相对位置不变。</li></ul><h4 id="冒泡排序的过程" tabindex="-1"><a class="header-anchor" href="#冒泡排序的过程"><span>冒泡排序的过程</span></a></h4><ol><li><strong>比较相邻元素</strong>：从数组的第一个元素开始，依次比较相邻的两个元素。如果前一个元素比后一个元素大，就交换这两个元素。</li><li><strong>重复过程</strong>：每一趟排序后，当前范围内最大的元素会被“冒泡”到最后一个位置。然后在未排序的部分重复相同的过程。</li><li><strong>缩小范围</strong>：每一趟排序后可以忽略已经排好序的最后一个元素，因为它已经是当前最大值。</li></ol><h4 id="冒泡排序的步骤" tabindex="-1"><a class="header-anchor" href="#冒泡排序的步骤"><span>冒泡排序的步骤</span></a></h4><p>假设我们有一个数组 <code>[5, 3, 8, 4, 2]</code>，冒泡排序的过程如下：</p><ol><li><strong>第一趟</strong>： <ul><li>比较 <code>[5, 3]</code>，交换为 <code>[3, 5, 8, 4, 2]</code></li><li>比较 <code>[5, 8]</code>，不交换</li><li>比较 <code>[8, 4]</code>，交换为 <code>[3, 5, 4, 8, 2]</code></li><li>比较 <code>[8, 2]</code>，交换为 <code>[3, 5, 4, 2, 8]</code></li><li>第一趟结束，最大元素 <code>8</code> 排到最后位置</li></ul></li><li><strong>第二趟</strong>： <ul><li>比较 <code>[3, 5]</code>，不交换</li><li>比较 <code>[5, 4]</code>，交换为 <code>[3, 4, 5, 2, 8]</code></li><li>比较 <code>[5, 2]</code>，交换为 <code>[3, 4, 2, 5, 8]</code></li><li>第二趟结束，次大元素 <code>5</code> 排到倒数第二位置</li></ul></li><li><strong>第三趟</strong>： <ul><li>比较 <code>[3, 4]</code>，不交换</li><li>比较 <code>[4, 2]</code>，交换为 <code>[3, 2, 4, 5, 8]</code></li><li>第三趟结束，第三大元素 <code>4</code> 排到倒数第三位置</li></ul></li><li><strong>第四趟</strong>： <ul><li>比较 <code>[3, 2]</code>，交换为 <code>[2, 3, 4, 5, 8]</code></li></ul></li></ol><p>此时数组已完全有序，冒泡排序结束。</p><h3 id="简单选择排序" tabindex="-1"><a class="header-anchor" href="#简单选择排序"><span>简单选择排序</span></a></h3><p>简单选择排序（Selection Sort）是一种直接、直观的排序算法。它的基本思想是通过多次选择最小或最大的元素，将其放到数组的正确位置上，逐步完成排序。该算法适用于小规模数据的排序，容易理解和实现。</p><h4 id="简单选择排序的特点" tabindex="-1"><a class="header-anchor" href="#简单选择排序的特点"><span>简单选择排序的特点</span></a></h4><ul><li><strong>时间复杂度</strong>：无论最佳还是最坏情况下，时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为每一趟都要遍历数组的剩余部分。</li><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，它是原地排序算法，不需要额外的存储空间。</li><li><strong>稳定性</strong>：简单选择排序通常是不稳定的，因为它在每一趟中直接交换最小（或最大）元素的位置，可能改变相等元素的顺序。</li></ul><h4 id="简单选择排序的过程" tabindex="-1"><a class="header-anchor" href="#简单选择排序的过程"><span>简单选择排序的过程</span></a></h4><ol><li><strong>选择最小（或最大）元素</strong>：从未排序的部分中找到最小的元素，将其放到未排序部分的开头。</li><li><strong>重复步骤</strong>：从下一个未排序的元素开始，重复这个过程，直到所有元素都排序完毕。</li></ol><h4 id="简单选择排序的步骤" tabindex="-1"><a class="header-anchor" href="#简单选择排序的步骤"><span>简单选择排序的步骤</span></a></h4><p>假设我们有一个数组 <code>[29, 10, 14, 37, 13]</code>，通过简单选择排序将它排序：</p><ol><li><p><strong>第一趟</strong>：找到最小值</p><ul><li>初始状态：<code>[29, 10, 14, 37, 13]</code></li><li>找到最小值 <code>10</code>，将其与第一个元素 <code>29</code> 交换</li><li>数组状态：<code>[10, 29, 14, 37, 13]</code></li></ul></li><li><p><strong>第二趟</strong>：在剩余未排序的部分中找最小值</p><ul><li><code>[10, 29, 14, 37, 13]</code>（第一个元素已排序）</li><li>找到最小值 <code>13</code>，将其与第二个元素 <code>29</code> 交换</li><li>数组状态：<code>[10, 13, 14, 37, 29]</code></li></ul></li><li><p><strong>第三趟</strong>：继续在未排序部分中找最小值</p><ul><li><code>[10, 13, 14, 37, 29]</code>（前两个元素已排序）</li><li>找到最小值 <code>14</code>，已在正确位置，无需交换</li><li>数组状态不变：<code>[10, 13, 14, 37, 29]</code></li></ul></li><li><p><strong>第四趟</strong>：对剩下部分进行排序</p><ul><li><p><code>[10, 13, 14, 37, 29]</code>（前三个元素已排序）</p></li><li><p>找到最小值 <code>29</code>，将其与第四个元素 <code>37</code> 交换</p></li><li><p>数组状态：<code>[10, 13, 14, 29, 37]</code></p></li></ul></li></ol><h3 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序"><span>堆排序</span></a></h3><p>堆排序（<em><strong>Heap Sort</strong></em>）是一种基于二叉堆数据结构的排序算法。它利用堆的特性（<strong>大顶堆</strong>或<strong>小顶堆</strong>）来实现排序。堆排序可以看作选择排序的一个优化版本，适用于需要高效处理大数据的情况，是一种 <strong>原地排序算法</strong>。</p><h4 id="堆排序的特点" tabindex="-1"><a class="header-anchor" href="#堆排序的特点"><span>堆排序的特点</span></a></h4><ul><li><strong>时间复杂度</strong>：平均和最坏时间复杂度都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_{2}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，适合大规模数据排序。</li><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，因为堆排序在原数组上进行。</li><li><strong>稳定性</strong>：堆排序是不稳定的，因为交换过程可能改变相等元素的相对顺序。</li></ul><h4 id="堆排序的过程" tabindex="-1"><a class="header-anchor" href="#堆排序的过程"><span>堆排序的过程</span></a></h4><p>堆排序分为两个阶段：</p><ol><li><strong>构建初始堆</strong>：将数组转换为一个大顶堆（如果是升序排序）或小顶堆（如果是降序排序）。在大顶堆中，堆顶元素为最大值。</li><li><strong>排序过程</strong>：将堆顶元素（最大值）移到数组末尾，并将剩下的部分重新调整为大顶堆，重复此操作，直到堆中仅剩一个元素。</li></ol><h4 id="堆排序的步骤" tabindex="-1"><a class="header-anchor" href="#堆排序的步骤"><span>堆排序的步骤</span></a></h4><h5 id="初始数组-2" tabindex="-1"><a class="header-anchor" href="#初始数组-2"><span>初始数组</span></a></h5><p>原数组为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[4, 10, 3, 5, 1]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>表示成完全二叉树为：</p><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        4</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      10   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    5   1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h5 id="构建大顶堆" tabindex="-1"><a class="header-anchor" href="#构建大顶堆"><span>构建大顶堆</span></a></h5><p>从最后一个非叶子节点开始调整。我们从 <code>10</code> 开始，然后处理 <code>4</code>。</p><p>调整 10 的子树</p><p>当前结构：</p><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        4</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      10   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    5   1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>10</code> 的子节点 <code>5</code> 和 <code>1</code> 均小于 <code>10</code>，所以不需要调整。</li></ul><p>调整 4 的子树</p><p>当前结构：</p><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        4</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      10   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    5   1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>10</code> 比 <code>4</code> 大，交换 <code>4</code> 和 <code>10</code>：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>       10</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      4   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    5   1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>接下来，调整新的位置的 <code>4</code>。节点 <code>5</code> 大于 <code>4</code>，交换 <code>4</code> 和 <code>5</code>：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>       10</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      5   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    4   1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构建完成的初始大顶堆为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[10, 5, 3, 4, 1]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h5 id="堆排序过程" tabindex="-1"><a class="header-anchor" href="#堆排序过程"><span>堆排序过程</span></a></h5><p>我们将堆顶元素与最后一个元素交换，然后重新调整剩余部分，重复此过程直到排序完成。</p><h6 id="第一次交换和调整" tabindex="-1"><a class="header-anchor" href="#第一次交换和调整"><span>第一次交换和调整</span></a></h6><ol><li><p><strong>交换</strong>堆顶 <code>10</code> 与最后一个元素 <code>1</code>：</p><ul><li>数组变为 <code>[1, 5, 3, 4, 10]</code></li><li>树结构：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        1</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      5   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    4   10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>重新调整大顶堆</strong>（忽略最后的 <code>10</code>）：</p><ul><li><code>5</code> 比 <code>1</code> 大，交换 <code>1</code> 和 <code>5</code>：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        5</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      1   3</span></span>
<span class="line"><span>     /</span></span>
<span class="line"><span>    4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>4</code> 比 <code>1</code> 大，交换 <code>1</code> 和 <code>4</code>：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        5</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      4   3</span></span>
<span class="line"><span>     /</span></span>
<span class="line"><span>    1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>调整后数组为 <code>[5, 4, 3, 1, 10]</code></li></ul></li></ol><hr><h6 id="第二次交换和调整" tabindex="-1"><a class="header-anchor" href="#第二次交换和调整"><span>第二次交换和调整</span></a></h6><ol><li><p><strong>交换</strong>堆顶 <code>5</code> 与倒数第二个元素 <code>1</code>：</p><ul><li>数组变为 <code>[1, 4, 3, 5, 10]</code></li><li>树结构：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>       1</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      4   3</span></span>
<span class="line"><span>     /</span></span>
<span class="line"><span>    5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>重新调整大顶堆</strong>（忽略 <code>5</code> 和 <code>10</code>）：</p><ul><li><code>4</code> 比 <code>1</code> 大，交换 <code>1</code> 和 <code>4</code>：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        4</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      1   3</span></span>
<span class="line"><span>     /</span></span>
<span class="line"><span>    5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>调整后数组为 <code>[4, 1, 3, 5, 10]</code></li></ul></li></ol><hr><h6 id="第三次交换和调整" tabindex="-1"><a class="header-anchor" href="#第三次交换和调整"><span>第三次交换和调整</span></a></h6><ol><li><p><strong>交换</strong>堆顶 <code>4</code> 与倒数第三个元素 <code>3</code>：</p><ul><li>数组变为 <code>[3, 1, 4, 5, 10]</code></li><li>树结构：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        3</span></span>
<span class="line"><span>       / \</span></span>
<span class="line"><span>      1   4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>重新调整大顶堆</strong>（忽略 <code>4</code>, <code>5</code>, 和 <code>10</code>）：</p><ul><li><code>3</code> 大于 <code>1</code>，无需调整。</li><li>调整后数组为 <code>[3, 1, 4, 5, 10]</code></li></ul></li></ol><hr><h6 id="第四次交换和调整" tabindex="-1"><a class="header-anchor" href="#第四次交换和调整"><span>第四次交换和调整</span></a></h6><ol><li><p><strong>交换</strong>堆顶 <code>3</code> 与倒数第四个元素 <code>1</code>：</p><ul><li>数组变为 <code>[1, 3, 4, 5, 10]</code></li><li>树结构：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        1</span></span>
<span class="line"><span>       /</span></span>
<span class="line"><span>      3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>重新调整大顶堆</strong>（忽略 <code>3</code>, <code>4</code>, <code>5</code>, 和 <code>10</code>）：</p><ul><li><code>3</code> 比 <code>1</code> 大，交换 <code>1</code> 和 <code>3</code>：</li></ul><div class="language-mathematica line-numbers-mode" data-ext="mathematica" data-title="mathematica"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>        3</span></span>
<span class="line"><span>       /</span></span>
<span class="line"><span>      1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>调整后数组为 <code>[1, 3, 4, 5, 10]</code></li></ul></li></ol><hr><h5 id="最终结果-1" tabindex="-1"><a class="header-anchor" href="#最终结果-1"><span>最终结果</span></a></h5><p>排序完成后的数组为：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[1, 3, 4, 5, 10]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h3><p>归并排序（<em>Merge Sort</em>）是一种基于分治法的高效排序算法。它的核心思想是将数组分成较小的部分，分别排序后再合并，最终得到一个有序数组。由于归并排序每次都将数组分割成两半，时间复杂度较低，适合大规模数据的排序。</p><h4 id="归并排序的特点" tabindex="-1"><a class="header-anchor" href="#归并排序的特点"><span>归并排序的特点</span></a></h4><ul><li><strong>时间复杂度</strong>：平均和最坏情况下都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_{2}n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li><strong>空间复杂度</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，需要额外空间来存储临时合并结果。</li><li><strong>稳定性</strong>：归并排序是稳定的，两个相等的元素在排序后相对位置不变。</li></ul><h4 id="归并排序的过程" tabindex="-1"><a class="header-anchor" href="#归并排序的过程"><span>归并排序的过程</span></a></h4><p>归并排序的基本步骤包括<strong>分割</strong>和<strong>合并</strong>两大阶段：</p><ol><li><strong>分割（Divide）</strong>：将数组递归地一分为二，直到每个子数组只有一个元素（单个元素视为已排序）。</li><li><strong>合并（Merge）</strong>：从小规模的子数组开始，将相邻的两个子数组合并成一个有序的较大数组，逐步完成合并，直到所有元素合并成一个完整的有序数组。</li></ol><h4 id="归并排序的步骤" tabindex="-1"><a class="header-anchor" href="#归并排序的步骤"><span>归并排序的步骤</span></a></h4><p>假设我们要对数组 <code>[8, 4, 5, 7, 1, 3, 6, 2]</code> 进行归并排序，具体操作如下：</p><ol><li><p><strong>分割阶段</strong>：</p><ul><li>将数组分成两部分：<code>[8, 4, 5, 7]</code> 和 <code>[1, 3, 6, 2]</code></li><li>继续分割：<code>[8, 4]</code>, <code>[5, 7]</code>, <code>[1, 3]</code>, <code>[6, 2]</code></li><li>再次分割：<code>[8]</code>, <code>[4]</code>, <code>[5]</code>, <code>[7]</code>, <code>[1]</code>, <code>[3]</code>, <code>[6]</code>, <code>[2]</code></li><li>直到每个子数组只有一个元素。</li></ul></li><li><p><strong>合并阶段</strong>：</p><ul><li><p>第一趟合并</p><p>（相邻两个单元素合并成有序对）：</p><ul><li><code>[8]</code> 和 <code>[4]</code> 合并成 <code>[4, 8]</code></li><li><code>[5]</code> 和 <code>[7]</code> 合并成 <code>[5, 7]</code></li><li><code>[1]</code> 和 <code>[3]</code> 合并成 <code>[1, 3]</code></li><li><code>[6]</code> 和 <code>[2]</code> 合并成 <code>[2, 6]</code></li></ul></li><li><p>第二趟合并</p><p>（每四个元素合并成有序小组）：</p><ul><li><code>[4, 8]</code> 和 <code>[5, 7]</code> 合并成 <code>[4, 5, 7, 8]</code></li><li><code>[1, 3]</code> 和 <code>[2, 6]</code> 合并成 <code>[1, 2, 3, 6]</code></li></ul></li><li><p>第三趟合并</p><p>（合并成完整的有序数组）：</p><ul><li><code>[4, 5, 7, 8]</code> 和 <code>[1, 2, 3, 6]</code> 合并成 <code>[1, 2, 3, 4, 5, 6, 7, 8]</code></li></ul></li></ul></li></ol></div></main><footer class="vp-doc-footer" data-v-1317b5aa data-v-f2100d82><!--[--><!--]--><!----><div class="contributors" data-v-f2100d82><span class="contributors-label" data-v-f2100d82>贡献者: </span><span class="contributors-info" data-v-f2100d82><!--[--><!--[--><span class="contributor" data-v-f2100d82>aliyun2753808549</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-f2100d82><div class="pager" data-v-f2100d82><a class="vp-link no-icon link pager-link prev" href="/article/3xxc0fv4/" data-v-f2100d82 data-v-442a52aa><!--[--><span class="desc" data-v-f2100d82>上一页</span><span class="title" data-v-f2100d82>问题归纳</span><!--]--><!----></a></div><div class="pager" data-v-f2100d82><a class="vp-link no-icon link pager-link next" href="/article/v4h0v0h8/" data-v-f2100d82 data-v-442a52aa><!--[--><span class="desc" data-v-f2100d82>下一页</span><span class="title" data-v-f2100d82>学习SpringSecurity</span><!--]--><!----></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button style="display:none;" type="button" class="vp-back-to-top" aria-label="back to top" data-v-68cd6b44 data-v-c122fdb6><span class="percent" data-allow-mismatch data-v-c122fdb6>0%</span><span class="show icon vpi-back-to-top" data-v-c122fdb6></span><svg aria-hidden="true" data-v-c122fdb6><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-c122fdb6></circle></svg></button><footer class="vp-footer" vp-footer data-v-68cd6b44 data-v-7631db44><!--[--><div class="container" data-v-7631db44><p class="message" data-v-7631db44>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-H92NnqWz.js" defer></script></body></html>