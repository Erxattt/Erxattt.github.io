## 排序

### 直接插入排序

直接插入排序是一种简单直观的排序算法。其基本思想是模拟打扑克牌时的整理过程：将牌一张张抽出，依次插入到合适的位置，使得手中的牌始终保持有序。对于每一个新元素，我们将其与前面的已排序元素进行比较，找到适当的位置插入，从而保持部分有序，直到处理完所有元素，最终实现整个数组的有序排列。

#### 直接插入排序的特点

1. **时间复杂度**：平均时间复杂度为 $O(n^2)$，最好情况为 $O(n)$（数组已基本有序），最坏情况为 $O(n^2)$（逆序数组）。
2. **空间复杂度**：为 $O(1)$，因为直接插入排序在原数组上操作，不需要额外的存储空间。
3. **稳定性**：直接插入排序是稳定的，相同元素的相对顺序不会改变。

------

#### 直接插入排序的过程

直接插入排序的核心思想是将数组分为已排序和未排序两部分，逐步将未排序部分的元素插入到已排序部分的合适位置：

1. 从数组的第二个元素开始，依次将每个元素插入到其前方已排序部分的正确位置。
2. 比较时，从当前元素逐个向前，与已排序部分的元素比较并后移，直到找到合适的位置插入。

------

#### 直接插入排序的步骤示例

假设我们有数组 `[5, 2, 9, 1, 5, 6]`，我们使用直接插入排序对其进行升序排序。

##### 初始数组

数组初始状态为：

```
[5, 2, 9, 1, 5, 6]
```

------

##### 第一步：插入元素 2

将 `2` 插入到已排序部分 `[5]` 中的合适位置：

- `2` 小于 `5`，所以将 `5` 后移，`2` 插入到第一个位置。

- 结果为：

  ```
  [2, 5, 9, 1, 5, 6]
  ```

------

##### 第二步：插入元素 9

将 `9` 插入到已排序部分 `[2, 5]` 的合适位置：

- `9` 大于 `5`，不需要移动，直接插入到当前位置。

- 结果为：

  ```
  [2, 5, 9, 1, 5, 6]
  ```

------

##### 第三步：插入元素 1

将 `1` 插入到已排序部分 `[2, 5, 9]` 中的合适位置：

- `1` 小于 `9`，将 `9` 后移。

- `1` 小于 `5`，将 `5` 后移。

- `1` 小于 `2`，将 `2` 后移，将 `1` 插入第一个位置。

- 结果为：

  ```
  [1, 2, 5, 9, 5, 6]
  ```

------

##### 第四步：插入元素 5

将 `5` 插入到已排序部分 `[1, 2, 5, 9]` 的合适位置：

- `5` 小于 `9`，将 `9` 后移，`5` 插入到第二个 `5` 的位置。

- 结果为：

  ```
  [1, 2, 5, 5, 9, 6]
  ```

------

##### 第五步：插入元素 6

将 `6` 插入到已排序部分 `[1, 2, 5, 5, 9]` 的合适位置：

- `6` 小于 `9`，将 `9` 后移，`6` 插入 `9` 的位置。

- 结果为：

  ```
  [1, 2, 5, 5, 6, 9]
  ```

### 希尔排序

希尔排序（***Shell Sort***）是一种**基于插入排序**的**改进**排序算法。它通过**分组**和**逐步减少间隔**的方式，使得数组中的元素逐步接近有序状态，然后在最后进行一次普通插入排序完成整个排序。希尔排序得名于发明者唐纳德·希尔（Donald Shell），它适合中小规模数据的排序，具有较高的效率。

#### 希尔排序的特点

- **时间复杂度**：根据不同的间隔序列，时间复杂度介于 $O(n^{1.3})$ 到 $O(n^2)$之间，通常优于简单插入排序。
- **空间复杂度**：$O(1)$，是原地排序算法。
- **稳定性**：希尔排序是不稳定的排序算法，因为在分组排序过程中，可能会改变相等元素的相对顺序。

#### 希尔排序的过程

1. **确定初始间隔（增量）**：选一个较大的间隔将数组分组，例如将间隔定为数组长度的一半。
2. **分组排序**：按间隔将数组分为多个子序列，每个子序列进行插入排序。
3. **缩小间隔**：逐步减小间隔，重复分组排序，直到间隔为1时执行一次完整的插入排序。
4. **结束**：当间隔为1且完成排序后，整个数组已达到有序状态。

#### 希尔排序的步骤

假设我们有一个数组 `[49, 38, 65, 97, 76, 13, 27, _49]`，希尔排序过程如下：

1. **第一趟排序**（间隔 = 4）：
   - 选择初始间隔为 `4`，将数组分成四组分别进行插入排序：
     - `[49, 76]`, `[38, 13]`, `[65, 27]`, `[97, _49]`
   - 排序后：
     - `[49, 13, 27, _49, 76, 38, 65, 97]`
2. **第二趟排序**（间隔 = 2）：
   - 将间隔缩小为 `2`，分成两组进行插入排序：
     - `[49, 27, 76, 65]`, `13, _49, 38, 97]`
   - 排序后：
     - `[27, 13, 49, 38, 65, _49, 76, 97]`
3. **第三趟排序**（间隔 = 1）：
   - 间隔缩小为 `1`，相当于对整个数组进行一次插入排序：
     - `[13, 27, 38, 49, _49, 65, 76, 97]`

此时，数组已完全有序，排序完成。

### 快速排序

快速排序的核心思想是通过**选择一个基准元素（pivot）**，将数组分为两部分：一部分小于基准元素，另一部分大于基准元素。具体步骤如下：

1. **选择基准元素**：通常选择数组中的某个元素作为基准（常用的是第一个元素、最后一个元素或随机元素）。
2. **分割**：通过比较，调整数组元素的位置，使得基准元素左边的元素都小于基准，右边的元素都大于基准。
3. **递归排序**：对基准元素左右两边的子数组分别进行递归排序。
4. **合并**：由于分割后子数组在原数组上，合并过程自然完成。

------

#### 快速排序的步骤示例

假设我们有数组 `[8, 4, 7, 6, 3, 5, 2, 1]`，要使用快速排序对其进行升序排序。

##### 初始数组

```
[3, 7, 8, 5, 2, 1, 9, 5, 4]
```

------

第一步：选择基准元素并分割

选择数组的最后一个元素 `4` 作为基准，将小于 `4` 的元素移到左边，大于 `4` 的移到右边。

1. **当前基准**：`4`

2. **开始分割**：

   - 从左到右遍历数组，把小于 `4` 的元素换到左侧。

   - **第一轮比较**：

     - `3` 小于 `4`，不用移动。

     - `7` 大于 `4`，跳过。

     - `8` 大于 `4`，跳过。

     - `5` 大于 `4`，跳过。

     - `2`小于 `4`，交换 `2`和 `7`：

       ```
       [3, 2, 8, 5, 7, 1, 9, 5, 4]
       ```

     - `1`小于 `4`，交换 `1`和 `8`：

       ```
       [3, 2, 1, 5, 7, 8, 9, 5, 4]
       ```

     - `9` 大于 `4`，跳过。

     - `5` 大于 `4`，跳过。

3. **交换基准**：将基准 `4` 放到中间位置，与 `5` 交换：

   ```
   [3, 2, 1, 4, 7, 8, 9, 5, 5]
   ```

4. **分割结果**：基准 `4` 将数组分成两部分：左侧 `[3, 2, 1]` 和右侧 `[7, 8, 9, 5, 5]`。

------

第二步：递归排序左侧子数组 `[3, 2, 1]`

对左侧子数组 `[3, 2, 1]` 选择 `1` 为基准，进行排序。

1. **当前基准**：`1`

2. **分割**：

   - 遍历 `[3, 2]`，发现都大于 `1`，所以 `1` 应该放到最左边。

   - 交换 `1`和 `3`：

     ```
     [1, 2, 3, 4, 7, 8, 9, 5, 5]
     ```

3. **左侧子数组已排序**：得到 `[1, 2, 3]`。

------

第三步：递归排序右侧子数组 `[7, 8, 9, 5, 5]`

对右侧子数组 `[7, 8, 9, 5, 5]` 选择最后一个元素 `5` 为基准。

1. **当前基准**：`5`

2. **分割**：

   - 遍历 `[7, 8, 9, 5]`，将小于 `5` 的元素移到左边。
   - 第一轮比较：
     - `7` 大于 `5`，跳过。
     - `8` 大于 `5`，跳过。
     - `9` 大于 `5`，跳过。
     - `5` 等于 `5`，保持不变。

3. **交换基准**：将 `5` 放到中间位置，与 `7` 交换：

   ```
   [1, 2, 3, 4, 5, 8, 9, 7, 5]
   ```

4. **分割结果**：基准 `5` 分割出 `[5]` 和 `[8, 9, 7]`。

------

第四步：继续递归排序右侧子数组 `[8, 9, 7]`

对 `[8, 9, 7]` 选择 `7` 为基准进行排序。

1. **当前基准**：`7`

2. **分割**：

   - 遍历 `[8, 9]`，发现都大于 `7`，所以 `7` 应放在最左边。

   - 交换 `7`和 `8`：

     ```
     [1, 2, 3, 4, 5, 5, 7, 8, 9]
     ```

3. **右侧子数组已排序**：得到 `[7, 8, 9]`。

------

##### 最终结果

快速排序完成后，整个数组为：

```
[1, 2, 3, 4, 5, 5, 7, 8, 9]
```

### 冒泡排序

冒泡排序（*Bubble Sort*）是一种简单的排序算法，它通过多次比较和交换相邻的元素，将较大的元素逐步“冒泡”到数组的末尾。冒泡排序适合对小规模数据进行排序，但在大规模数据上效率较低。

#### 冒泡排序的特点

- **时间复杂度**：最坏和平均情况下的时间复杂度都是$O(n^2)$，因为需要对每对元素进行比较。
- **空间复杂度**：$O(1)$，它是原地排序算法，不需要额外的存储空间。
- **稳定性**：冒泡排序是稳定的排序算法，两个相等的元素在排序后相对位置不变。

#### 冒泡排序的过程

1. **比较相邻元素**：从数组的第一个元素开始，依次比较相邻的两个元素。如果前一个元素比后一个元素大，就交换这两个元素。
2. **重复过程**：每一趟排序后，当前范围内最大的元素会被“冒泡”到最后一个位置。然后在未排序的部分重复相同的过程。
3. **缩小范围**：每一趟排序后可以忽略已经排好序的最后一个元素，因为它已经是当前最大值。

#### 冒泡排序的步骤

假设我们有一个数组 `[5, 3, 8, 4, 2]`，冒泡排序的过程如下：

1. **第一趟**：
   - 比较 `[5, 3]`，交换为 `[3, 5, 8, 4, 2]`
   - 比较 `[5, 8]`，不交换
   - 比较 `[8, 4]`，交换为 `[3, 5, 4, 8, 2]`
   - 比较 `[8, 2]`，交换为 `[3, 5, 4, 2, 8]`
   - 第一趟结束，最大元素 `8` 排到最后位置
2. **第二趟**：
   - 比较 `[3, 5]`，不交换
   - 比较 `[5, 4]`，交换为 `[3, 4, 5, 2, 8]`
   - 比较 `[5, 2]`，交换为 `[3, 4, 2, 5, 8]`
   - 第二趟结束，次大元素 `5` 排到倒数第二位置
3. **第三趟**：
   - 比较 `[3, 4]`，不交换
   - 比较 `[4, 2]`，交换为 `[3, 2, 4, 5, 8]`
   - 第三趟结束，第三大元素 `4` 排到倒数第三位置
4. **第四趟**：
   - 比较 `[3, 2]`，交换为 `[2, 3, 4, 5, 8]`

此时数组已完全有序，冒泡排序结束。

### 简单选择排序

简单选择排序（Selection Sort）是一种直接、直观的排序算法。它的基本思想是通过多次选择最小或最大的元素，将其放到数组的正确位置上，逐步完成排序。该算法适用于小规模数据的排序，容易理解和实现。

#### 简单选择排序的特点

- **时间复杂度**：无论最佳还是最坏情况下，时间复杂度都是 $O(n^2)$，因为每一趟都要遍历数组的剩余部分。
- **空间复杂度**：$O(1)$，它是原地排序算法，不需要额外的存储空间。
- **稳定性**：简单选择排序通常是不稳定的，因为它在每一趟中直接交换最小（或最大）元素的位置，可能改变相等元素的顺序。

#### 简单选择排序的过程

1. **选择最小（或最大）元素**：从未排序的部分中找到最小的元素，将其放到未排序部分的开头。
2. **重复步骤**：从下一个未排序的元素开始，重复这个过程，直到所有元素都排序完毕。

#### 简单选择排序的步骤

假设我们有一个数组 `[29, 10, 14, 37, 13]`，通过简单选择排序将它排序：

1. **第一趟**：找到最小值

   - 初始状态：`[29, 10, 14, 37, 13]`
   - 找到最小值 `10`，将其与第一个元素 `29` 交换
   - 数组状态：`[10, 29, 14, 37, 13]`

2. **第二趟**：在剩余未排序的部分中找最小值

   - `[10, 29, 14, 37, 13]`（第一个元素已排序）
   - 找到最小值 `13`，将其与第二个元素 `29` 交换
   - 数组状态：`[10, 13, 14, 37, 29]`

3. **第三趟**：继续在未排序部分中找最小值

   - `[10, 13, 14, 37, 29]`（前两个元素已排序）
   - 找到最小值 `14`，已在正确位置，无需交换
   - 数组状态不变：`[10, 13, 14, 37, 29]`

4. **第四趟**：对剩下部分进行排序

   - `[10, 13, 14, 37, 29]`（前三个元素已排序）

   - 找到最小值 `29`，将其与第四个元素 `37` 交换

   - 数组状态：`[10, 13, 14, 29, 37]`

     

### 堆排序

堆排序（***Heap Sort***）是一种基于二叉堆数据结构的排序算法。它利用堆的特性（**大顶堆**或**小顶堆**）来实现排序。堆排序可以看作选择排序的一个优化版本，适用于需要高效处理大数据的情况，是一种 **原地排序算法**。

#### 堆排序的特点

- **时间复杂度**：平均和最坏时间复杂度都是 $O(nlog_{2}n)$，适合大规模数据排序。
- **空间复杂度**：$O(1)$，因为堆排序在原数组上进行。
- **稳定性**：堆排序是不稳定的，因为交换过程可能改变相等元素的相对顺序。

#### 堆排序的过程

堆排序分为两个阶段：

1. **构建初始堆**：将数组转换为一个大顶堆（如果是升序排序）或小顶堆（如果是降序排序）。在大顶堆中，堆顶元素为最大值。
2. **排序过程**：将堆顶元素（最大值）移到数组末尾，并将剩下的部分重新调整为大顶堆，重复此操作，直到堆中仅剩一个元素。

#### 堆排序的步骤

##### 初始数组

原数组为：

```
[4, 10, 3, 5, 1]
```

表示成完全二叉树为：

```mathematica
        4
       / \
      10   3
     / \
    5   1
```

------

##### 构建大顶堆

从最后一个非叶子节点开始调整。我们从 `10` 开始，然后处理 `4`。

调整 10 的子树

当前结构：

```mathematica
        4
       / \
      10   3
     / \
    5   1
```

- `10` 的子节点 `5` 和 `1` 均小于 `10`，所以不需要调整。

调整 4 的子树

当前结构：

```mathematica
        4
       / \
      10   3
     / \
    5   1
```

- `10` 比 `4` 大，交换 `4` 和 `10`：

```mathematica
       10
       / \
      4   3
     / \
    5   1
```

- 接下来，调整新的位置的 `4`。节点 `5` 大于 `4`，交换 `4` 和 `5`：

```mathematica
       10
       / \
      5   3
     / \
    4   1
```

构建完成的初始大顶堆为：

```
[10, 5, 3, 4, 1]
```

------

##### 堆排序过程

我们将堆顶元素与最后一个元素交换，然后重新调整剩余部分，重复此过程直到排序完成。

###### 第一次交换和调整

1. **交换**堆顶 `10` 与最后一个元素 `1`：

   - 数组变为 `[1, 5, 3, 4, 10]`
   - 树结构：

   ```mathematica
           1
          / \
         5   3
        / \
       4   10
   ```

2. **重新调整大顶堆**（忽略最后的 `10`）：

   - `5` 比 `1` 大，交换 `1` 和 `5`：

   ```mathematica
           5
          / \
         1   3
        /
       4
   ```

   - `4` 比 `1` 大，交换 `1` 和 `4`：

   ```mathematica
           5
          / \
         4   3
        /
       1
   ```

   - 调整后数组为 `[5, 4, 3, 1, 10]`

------

###### 第二次交换和调整

1. **交换**堆顶 `5` 与倒数第二个元素 `1`：

   - 数组变为 `[1, 4, 3, 5, 10]`
   - 树结构：

   ```mathematica
          1
          / \
         4   3
        /
       5
   ```

2. **重新调整大顶堆**（忽略 `5` 和 `10`）：

   - `4` 比 `1` 大，交换 `1` 和 `4`：

   ```mathematica
           4
          / \
         1   3
        /
       5
   ```

   - 调整后数组为 `[4, 1, 3, 5, 10]`

------

###### 第三次交换和调整

1. **交换**堆顶 `4` 与倒数第三个元素 `3`：

   - 数组变为 `[3, 1, 4, 5, 10]`
   - 树结构：

   ```mathematica
           3
          / \
         1   4
   ```

2. **重新调整大顶堆**（忽略 `4`, `5`, 和 `10`）：

   - `3` 大于 `1`，无需调整。
   - 调整后数组为 `[3, 1, 4, 5, 10]`

------

###### 第四次交换和调整

1. **交换**堆顶 `3` 与倒数第四个元素 `1`：

   - 数组变为 `[1, 3, 4, 5, 10]`
   - 树结构：

   ```mathematica
           1
          /
         3
   ```

2. **重新调整大顶堆**（忽略 `3`, `4`, `5`, 和 `10`）：

   - `3` 比 `1` 大，交换 `1` 和 `3`：

   ```mathematica
           3
          /
         1
   ```

   - 调整后数组为 `[1, 3, 4, 5, 10]`

------

##### 最终结果

排序完成后的数组为：

```
[1, 3, 4, 5, 10]
```

### 归并排序

归并排序（*Merge Sort*）是一种基于分治法的高效排序算法。它的核心思想是将数组分成较小的部分，分别排序后再合并，最终得到一个有序数组。由于归并排序每次都将数组分割成两半，时间复杂度较低，适合大规模数据的排序。

#### 归并排序的特点

- **时间复杂度**：平均和最坏情况下都是 $O(nlog_{2}n)$。
- **空间复杂度**：$O(n)$，需要额外空间来存储临时合并结果。
- **稳定性**：归并排序是稳定的，两个相等的元素在排序后相对位置不变。

#### 归并排序的过程

归并排序的基本步骤包括**分割**和**合并**两大阶段：

1. **分割（Divide）**：将数组递归地一分为二，直到每个子数组只有一个元素（单个元素视为已排序）。
2. **合并（Merge）**：从小规模的子数组开始，将相邻的两个子数组合并成一个有序的较大数组，逐步完成合并，直到所有元素合并成一个完整的有序数组。

#### 归并排序的步骤

假设我们要对数组 `[8, 4, 5, 7, 1, 3, 6, 2]` 进行归并排序，具体操作如下：

1. **分割阶段**：

   - 将数组分成两部分：`[8, 4, 5, 7]` 和 `[1, 3, 6, 2]`
   - 继续分割：`[8, 4]`, `[5, 7]`, `[1, 3]`, `[6, 2]`
   - 再次分割：`[8]`, `[4]`, `[5]`, `[7]`, `[1]`, `[3]`, `[6]`, `[2]`
   - 直到每个子数组只有一个元素。

2. **合并阶段**：

   - 第一趟合并

     （相邻两个单元素合并成有序对）：

     - `[8]` 和 `[4]` 合并成 `[4, 8]`
     - `[5]` 和 `[7]` 合并成 `[5, 7]`
     - `[1]` 和 `[3]` 合并成 `[1, 3]`
     - `[6]` 和 `[2]` 合并成 `[2, 6]`

   - 第二趟合并

     （每四个元素合并成有序小组）：

     - `[4, 8]` 和 `[5, 7]` 合并成 `[4, 5, 7, 8]`
     - `[1, 3]` 和 `[2, 6]` 合并成 `[1, 2, 3, 6]`

   - 第三趟合并

     （合并成完整的有序数组）：

     - `[4, 5, 7, 8]` 和 `[1, 2, 3, 6]` 合并成 `[1, 2, 3, 4, 5, 6, 7, 8]`